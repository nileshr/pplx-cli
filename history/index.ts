import { db, getHistoryDir } from "../db";
import { history, type NewHistoryEntry, type HistoryEntry } from "../db/schema";
import { desc, like, eq } from "drizzle-orm";
import {
  writeFileSync,
  readdirSync,
  unlinkSync,
  readFileSync,
  existsSync,
} from "fs";
import { join } from "path";

/**
 * Generate a short hash from an ID
 * Uses base36 encoding with a prefix for readability
 */
export function generateHash(id: number): string {
  // Combine ID with a simple encoding to create a short hash
  const base36 = id.toString(36).padStart(4, "0");
  return base36;
}

/**
 * Parse a hash back to an ID
 */
export function parseHash(hash: string): number | null {
  try {
    const id = parseInt(hash, 36);
    return isNaN(id) ? null : id;
  } catch {
    return null;
  }
}

/**
 * History entry with hash
 */
export interface HistoryEntryWithHash extends HistoryEntry {
  hash: string;
}

interface SaveHistoryParams {
  query: string;
  command: string;
  model: string;
  response: string;
  citations?: Array<{ title: string; url: string; date?: string }>;
  promptTokens?: number;
  completionTokens?: number;
  totalTokens?: number;
  durationSeconds?: number;
}

/**
 * Generate a sanitized filename from the query
 */
function generateFilename(query: string, timestamp: Date): string {
  const date = timestamp.toISOString().slice(0, 10); // YYYY-MM-DD
  const time = timestamp.toISOString().slice(11, 19).replace(/:/g, "-"); // HH-MM-SS
  const slug = query
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .slice(0, 50)
    .replace(/-+$/, ""); // Remove trailing dashes

  return `${date}_${time}_${slug}.md`;
}

/**
 * Generate markdown content for the history file
 */
function generateMarkdown(params: SaveHistoryParams, timestamp: Date): string {
  const citationsMarkdown = params.citations?.length
    ? `\n## üìö Sources\n\n${params.citations
        .map(
          (c, i) =>
            `${i + 1}. [${c.title}](${c.url})${c.date ? ` - ${c.date}` : ""}`,
        )
        .join("\n")}\n`
    : "";

  const statsMarkdown = params.totalTokens
    ? `\n## üìä Statistics\n
| Metric | Value |
|--------|-------|
| Total Tokens | ${params.totalTokens} |
| Prompt Tokens | ${params.promptTokens} |
| Completion Tokens | ${params.completionTokens} |
| Duration | ${params.durationSeconds?.toFixed(2)}s |
| Model | \`${params.model}\` |
| Command | \`${params.command}\` |
`
    : "";

  return `# ${params.query}

> **Query executed on ${timestamp.toLocaleString()}**

---

## üí¨ Response

${params.response}
${citationsMarkdown}${statsMarkdown}
---

*Generated by [pplx-cli](https://github.com/perplexity/pplx-cli)*
`;
}

/**
 * Save a history entry to the database and create markdown file
 */
export async function saveHistory(
  params: SaveHistoryParams,
): Promise<HistoryEntry> {
  const timestamp = new Date();
  const filename = generateFilename(params.query, timestamp);
  const historyDir = getHistoryDir();
  const filepath = join(historyDir, filename);

  // Generate and write markdown file (use sync to avoid issues)
  const markdown = generateMarkdown(params, timestamp);
  writeFileSync(filepath, markdown, "utf-8");

  // Save to database
  const entry: NewHistoryEntry = {
    timestamp: timestamp.getTime(),
    query: params.query,
    command: params.command,
    model: params.model,
    response: params.response,
    citations: params.citations ? JSON.stringify(params.citations) : null,
    promptTokens: params.promptTokens,
    completionTokens: params.completionTokens,
    totalTokens: params.totalTokens,
    durationSeconds: params.durationSeconds,
  };

  const result = await db.insert(history).values(entry).returning();
  const inserted = result[0];
  if (!inserted) {
    throw new Error("Failed to insert history entry");
  }

  console.log(`üìÅ Saved to: ${filepath}`);
  return inserted;
}

/**
 * Get recent history entries
 */
export async function getRecentHistory(limit = 10): Promise<HistoryEntry[]> {
  return db
    .select()
    .from(history)
    .orderBy(desc(history.timestamp))
    .limit(limit);
}

/**
 * Search history by query text
 */
export async function searchHistory(
  searchTerm: string,
): Promise<HistoryEntry[]> {
  return db
    .select()
    .from(history)
    .where(like(history.query, `%${searchTerm}%`))
    .orderBy(desc(history.timestamp))
    .limit(50);
}

/**
 * Get all history entries
 */
export async function getAllHistory(): Promise<HistoryEntry[]> {
  return db.select().from(history).orderBy(desc(history.timestamp));
}

/**
 * Clear all history entries and files
 */
export async function clearHistory(): Promise<void> {
  // Clear database
  await db.delete(history);

  // Clear files
  const historyDir = getHistoryDir();
  try {
    const files = readdirSync(historyDir);
    for (const file of files) {
      if (file.endsWith(".md")) {
        unlinkSync(join(historyDir, file));
      }
    }
  } catch (error) {
    console.error("Failed to clear history files:", error);
  }
}

/**
 * Get history entry by hash
 */
export async function getHistoryByHash(
  hash: string,
): Promise<HistoryEntry | null> {
  const id = parseHash(hash);
  if (id === null) return null;

  const result = await db.select().from(history).where(eq(history.id, id));
  return result[0] || null;
}

/**
 * Get the markdown file path for a history entry
 * Finds the file by matching timestamp and query
 */
export function getMarkdownFilePath(entry: HistoryEntry): string | null {
  const historyDir = getHistoryDir();
  const timestamp = new Date(entry.timestamp);
  const expectedFilename = generateFilename(entry.query, timestamp);
  const filepath = join(historyDir, expectedFilename);

  if (existsSync(filepath)) {
    return filepath;
  }

  // Fallback: search for files with matching date/time prefix
  try {
    const files = readdirSync(historyDir);
    const datePrefix = timestamp.toISOString().slice(0, 10); // YYYY-MM-DD
    const timePrefix = timestamp.toISOString().slice(11, 19).replace(/:/g, "-"); // HH-MM-SS
    const prefix = `${datePrefix}_${timePrefix}`;

    for (const file of files) {
      if (file.startsWith(prefix) && file.endsWith(".md")) {
        return join(historyDir, file);
      }
    }
  } catch {
    // Directory doesn't exist or can't be read
  }

  return null;
}

/**
 * Get markdown content for a history entry
 */
export function getMarkdownContent(entry: HistoryEntry): string | null {
  const filepath = getMarkdownFilePath(entry);
  if (!filepath) return null;

  try {
    return readFileSync(filepath, "utf-8");
  } catch {
    return null;
  }
}

/**
 * Get recent history entries with hashes
 */
export async function getRecentHistoryWithHashes(
  limit = 10,
): Promise<HistoryEntryWithHash[]> {
  const entries = await getRecentHistory(limit);
  return entries.map((entry) => ({
    ...entry,
    hash: generateHash(entry.id),
  }));
}
